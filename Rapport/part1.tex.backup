\section{Premiers filtres}
Le code qui nous a été donné nous permet, de base, d'encoder ou de décoder un fichier en fonction d'une clé donnée. Dans notre cas, nous ne connaissons pas la clé permettant de déchiffrer correctement les fichiers. Ainsi, dans un premier temps, nous avons implémenté une boucle permettant de tester toutes les clés possibles pour un fichier.\\
Ici, la clé fait une longueur de 59 bits soit 8 octets. Pour les besoins de résolution plus rapide, nous connaissons 44 bits de la clé ($5,5$ octets). Cela laisse tout de même une possibilité de $2^{15}$ clés à tester (32768). Il est alors impossible de vérifier \enquote{à la main} toutes les clés.\\
C'est dans cette optique que nous devons implémenter des filtres. Ces derniers vont nous permettre de savoir quels sont les fichiers qui sont le plus probables d'être des textes lisibles.\\
Nous avons alors pensé à deux grand types de filtres.
\section{Encodage des caractères}
Dans un premier temps, nous avons voulu travailler avec l'encodage des caractères. En effet, nous savons ici que les documents chiffrés sont des documents textes. Il est alors simple, une fois décodé de vérifier si les caractères sont imprimables ou non.\\
Le premier filtre de ce genre que nous avons mis en place permet de vérifier si un caractère donné est un caractère imprimable :
\begin{lstlisting}[style=customc]
 int is_printable(mot08 in){
  int result = 0;
  if(in == ' ' || (in >= 'a' && in <= 'z'))
    return result;
}
\end{lstlisting}
Cependant ce filtre ne prend pas en compte les caractères non visibles comme le retour chariot. Il nous a alors fallu mettre en place un filtre plus évolué.\\
Le second filtre que nous avons mis en place permet de vérifier si le caractère décodé fait partie de la table ASCII :
\begin{lstlisting}[style=customc]
 int is_ascii(mot08 in){
  if(isprint((char)(in)) != 0 || (int)(in) == 13 || (int)(in) == 0 || (int)(in) == 10){
    return 0;
  }else{
    return 1;
  }
}
\end{lstlisting}
Ce dernier permet de prendre en considération les tabulations, retours à la ligne, etc\ldots Cependant, en utilisant ce filtre sur certains documents comme \textit{marret.cry}, il n'était pas possible de trouver un seul fichier correct. En effet, il s'avère que \textit{marret.cry} est un texte comportant des accents. Or, la table ASCII ne comprend pas les lettres avec accents.\\
Ainsi, nous avons choisi d'utiliser l'UTF-8 pour l'encodage de notre troisième filtre. 
\epigraph{\textit{L'UTF-8 est un codage de caractères informatiques conçu pour coder l’ensemble des caractères du \enquote{répertoire universel de caractères codés}, initialement développé par l’ISO dans la norme internationale ISO/CEI 10646, aujourd’hui totalement compatible avec le standard Unicode, en restant compatible avec la norme ASCII limitée à l’anglais de base (et quelques autres langues beaucoup moins fréquentes), mais très largement répandue depuis des décennies.}}{Wikipedia\cite{UTF8}}
Ainsi, de part la définition de l'UTF-8, nous sommes quasiment certains de pouvoir retrouver un texte, peut importe la langue dans laquelle il a été écrit. Le filtre est alors le suivant :
\begin{lstlisting}[style=customc]
 int is_utf8(mot08 in){
  if (((unsigned char)(in) >= 0x00 && (unsigned char)(in) <= 0x7f) || ((unsigned char)(in) >= 0xa0 && (unsigned char)(in) <= 0xff)){
    return 0;
  }else{
    return 1;
  }
}
\end{lstlisting}
